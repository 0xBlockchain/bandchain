// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: x/oracle/types/types.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ResolveStatus int32

const (
	ResolveStatus_Open    ResolveStatus = 0
	ResolveStatus_Success ResolveStatus = 1
	ResolveStatus_Failure ResolveStatus = 2
	ResolveStatus_Expired ResolveStatus = 3
)

var ResolveStatus_name = map[int32]string{
	0: "Open",
	1: "Success",
	2: "Failure",
	3: "Expired",
}

var ResolveStatus_value = map[string]int32{
	"Open":    0,
	"Success": 1,
	"Failure": 2,
	"Expired": 3,
}

func (x ResolveStatus) String() string {
	return proto.EnumName(ResolveStatus_name, int32(x))
}

func (ResolveStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{0}
}

// MsgRequestData is a message for requesting a new data request to an existing
// oracle script.
type MsgRequestData struct {
	OracleScriptID           OracleScriptID                                `protobuf:"varint,1,opt,name=oracle_script_id,json=oracleScriptId,proto3,casttype=OracleScriptID" json:"oracle_script_id,omitempty"`
	Calldata                 []byte                                        `protobuf:"bytes,2,opt,name=calldata,proto3" json:"calldata,omitempty"`
	RequestedValidatorCount  int64                                         `protobuf:"varint,3,opt,name=requested_validator_count,json=requestedValidatorCount,proto3" json:"requested_validator_count,omitempty"`
	SufficientValidatorCount int64                                         `protobuf:"varint,4,opt,name=sufficient_validator_count,json=sufficientValidatorCount,proto3" json:"sufficient_validator_count,omitempty"`
	ClientID                 string                                        `protobuf:"bytes,5,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	Sender                   github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,6,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty"`
}

func (m *MsgRequestData) Reset()         { *m = MsgRequestData{} }
func (m *MsgRequestData) String() string { return proto.CompactTextString(m) }
func (*MsgRequestData) ProtoMessage()    {}
func (*MsgRequestData) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{0}
}
func (m *MsgRequestData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestData.Merge(m, src)
}
func (m *MsgRequestData) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestData) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestData.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestData proto.InternalMessageInfo

func (m *MsgRequestData) GetOracleScriptID() OracleScriptID {
	if m != nil {
		return m.OracleScriptID
	}
	return 0
}

func (m *MsgRequestData) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

func (m *MsgRequestData) GetRequestedValidatorCount() int64 {
	if m != nil {
		return m.RequestedValidatorCount
	}
	return 0
}

func (m *MsgRequestData) GetSufficientValidatorCount() int64 {
	if m != nil {
		return m.SufficientValidatorCount
	}
	return 0
}

func (m *MsgRequestData) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *MsgRequestData) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

// MsgReportData is a message sent by each of the block validators to respond to
// a data request.
type MsgReportData struct {
	RequestID RequestID                                     `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	DataSet   RawReports                                    `protobuf:"bytes,2,rep,name=data_set,json=dataSet,proto3,castrepeated=RawReports" json:"data_set"`
	Validator github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,3,opt,name=validator,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"validator,omitempty"`
	Reporter  github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,4,opt,name=reporter,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"reporter,omitempty"`
}

func (m *MsgReportData) Reset()         { *m = MsgReportData{} }
func (m *MsgReportData) String() string { return proto.CompactTextString(m) }
func (*MsgReportData) ProtoMessage()    {}
func (*MsgReportData) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{1}
}
func (m *MsgReportData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReportData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReportData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReportData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReportData.Merge(m, src)
}
func (m *MsgReportData) XXX_Size() int {
	return m.Size()
}
func (m *MsgReportData) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReportData.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReportData proto.InternalMessageInfo

func (m *MsgReportData) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *MsgReportData) GetDataSet() RawReports {
	if m != nil {
		return m.DataSet
	}
	return nil
}

func (m *MsgReportData) GetValidator() github_com_cosmos_cosmos_sdk_types.ValAddress {
	if m != nil {
		return m.Validator
	}
	return nil
}

func (m *MsgReportData) GetReporter() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Reporter
	}
	return nil
}

// MsgCreateDataSource is a message for creating a new data source.
type MsgCreateDataSource struct {
	Owner       github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	Name        string                                        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description string                                        `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Fee         github_com_cosmos_cosmos_sdk_types.Coins      `protobuf:"bytes,4,rep,name=fee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee"`
	Executable  []byte                                        `protobuf:"bytes,5,opt,name=executable,proto3" json:"executable,omitempty"`
	Sender      github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,6,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty"`
}

func (m *MsgCreateDataSource) Reset()         { *m = MsgCreateDataSource{} }
func (m *MsgCreateDataSource) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDataSource) ProtoMessage()    {}
func (*MsgCreateDataSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{2}
}
func (m *MsgCreateDataSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDataSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDataSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDataSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDataSource.Merge(m, src)
}
func (m *MsgCreateDataSource) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDataSource) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDataSource.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDataSource proto.InternalMessageInfo

func (m *MsgCreateDataSource) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *MsgCreateDataSource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateDataSource) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgCreateDataSource) GetFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *MsgCreateDataSource) GetExecutable() []byte {
	if m != nil {
		return m.Executable
	}
	return nil
}

func (m *MsgCreateDataSource) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

// MsgEditDataSource is a message for editing an existing data source.
type MsgEditDataSource struct {
	DataSourceID DataSourceID                                  `protobuf:"varint,1,opt,name=data_source_id,json=dataSourceId,proto3,casttype=DataSourceID" json:"data_source_id,omitempty"`
	Owner        github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	Name         string                                        `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description  string                                        `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Fee          github_com_cosmos_cosmos_sdk_types.Coins      `protobuf:"bytes,5,rep,name=fee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee"`
	Executable   []byte                                        `protobuf:"bytes,6,opt,name=executable,proto3" json:"executable,omitempty"`
	Sender       github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,7,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty"`
}

func (m *MsgEditDataSource) Reset()         { *m = MsgEditDataSource{} }
func (m *MsgEditDataSource) String() string { return proto.CompactTextString(m) }
func (*MsgEditDataSource) ProtoMessage()    {}
func (*MsgEditDataSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{3}
}
func (m *MsgEditDataSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEditDataSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEditDataSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEditDataSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEditDataSource.Merge(m, src)
}
func (m *MsgEditDataSource) XXX_Size() int {
	return m.Size()
}
func (m *MsgEditDataSource) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEditDataSource.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEditDataSource proto.InternalMessageInfo

func (m *MsgEditDataSource) GetDataSourceID() DataSourceID {
	if m != nil {
		return m.DataSourceID
	}
	return 0
}

func (m *MsgEditDataSource) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *MsgEditDataSource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgEditDataSource) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgEditDataSource) GetFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *MsgEditDataSource) GetExecutable() []byte {
	if m != nil {
		return m.Executable
	}
	return nil
}

func (m *MsgEditDataSource) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

// MsgCreateOracleScript is a message for creating an oracle script.
type MsgCreateOracleScript struct {
	Owner         github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	Name          string                                        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description   string                                        `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Code          []byte                                        `protobuf:"bytes,4,opt,name=code,proto3" json:"code,omitempty"`
	Schema        string                                        `protobuf:"bytes,5,opt,name=schema,proto3" json:"schema,omitempty"`
	SourceCodeURL string                                        `protobuf:"bytes,6,opt,name=source_code_url,json=sourceCodeUrl,proto3" json:"source_code_url,omitempty"`
	Sender        github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,7,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty"`
}

func (m *MsgCreateOracleScript) Reset()         { *m = MsgCreateOracleScript{} }
func (m *MsgCreateOracleScript) String() string { return proto.CompactTextString(m) }
func (*MsgCreateOracleScript) ProtoMessage()    {}
func (*MsgCreateOracleScript) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{4}
}
func (m *MsgCreateOracleScript) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateOracleScript) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateOracleScript.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateOracleScript) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateOracleScript.Merge(m, src)
}
func (m *MsgCreateOracleScript) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateOracleScript) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateOracleScript.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateOracleScript proto.InternalMessageInfo

func (m *MsgCreateOracleScript) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *MsgCreateOracleScript) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateOracleScript) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgCreateOracleScript) GetCode() []byte {
	if m != nil {
		return m.Code
	}
	return nil
}

func (m *MsgCreateOracleScript) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *MsgCreateOracleScript) GetSourceCodeURL() string {
	if m != nil {
		return m.SourceCodeURL
	}
	return ""
}

func (m *MsgCreateOracleScript) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

// MsgEditOracleScript is a message for editing an existing oracle script.
type MsgEditOracleScript struct {
	OracleScriptID OracleScriptID                                `protobuf:"varint,1,opt,name=oracle_script_id,json=oracleScriptId,proto3,casttype=OracleScriptID" json:"oracle_script_id,omitempty"`
	Owner          github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	Name           string                                        `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description    string                                        `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Code           []byte                                        `protobuf:"bytes,5,opt,name=code,proto3" json:"code,omitempty"`
	Schema         string                                        `protobuf:"bytes,6,opt,name=schema,proto3" json:"schema,omitempty"`
	SourceCodeURL  string                                        `protobuf:"bytes,7,opt,name=source_code_url,json=sourceCodeUrl,proto3" json:"source_code_url,omitempty"`
	Sender         github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,8,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty"`
}

func (m *MsgEditOracleScript) Reset()         { *m = MsgEditOracleScript{} }
func (m *MsgEditOracleScript) String() string { return proto.CompactTextString(m) }
func (*MsgEditOracleScript) ProtoMessage()    {}
func (*MsgEditOracleScript) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{5}
}
func (m *MsgEditOracleScript) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEditOracleScript) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEditOracleScript.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEditOracleScript) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEditOracleScript.Merge(m, src)
}
func (m *MsgEditOracleScript) XXX_Size() int {
	return m.Size()
}
func (m *MsgEditOracleScript) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEditOracleScript.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEditOracleScript proto.InternalMessageInfo

func (m *MsgEditOracleScript) GetOracleScriptID() OracleScriptID {
	if m != nil {
		return m.OracleScriptID
	}
	return 0
}

func (m *MsgEditOracleScript) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *MsgEditOracleScript) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgEditOracleScript) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgEditOracleScript) GetCode() []byte {
	if m != nil {
		return m.Code
	}
	return nil
}

func (m *MsgEditOracleScript) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *MsgEditOracleScript) GetSourceCodeURL() string {
	if m != nil {
		return m.SourceCodeURL
	}
	return ""
}

func (m *MsgEditOracleScript) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

// MsgAddOracleAddress is a message for adding an agent authorized to submit
// report transactions.
type MsgAddOracleAddress struct {
	Validator github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,1,opt,name=validator,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"validator,omitempty"`
	Reporter  github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=reporter,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"reporter,omitempty"`
}

func (m *MsgAddOracleAddress) Reset()         { *m = MsgAddOracleAddress{} }
func (m *MsgAddOracleAddress) String() string { return proto.CompactTextString(m) }
func (*MsgAddOracleAddress) ProtoMessage()    {}
func (*MsgAddOracleAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{6}
}
func (m *MsgAddOracleAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddOracleAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddOracleAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddOracleAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddOracleAddress.Merge(m, src)
}
func (m *MsgAddOracleAddress) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddOracleAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddOracleAddress.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddOracleAddress proto.InternalMessageInfo

func (m *MsgAddOracleAddress) GetValidator() github_com_cosmos_cosmos_sdk_types.ValAddress {
	if m != nil {
		return m.Validator
	}
	return nil
}

func (m *MsgAddOracleAddress) GetReporter() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Reporter
	}
	return nil
}

// MsgRemoveOracleAddress is a message for removing an agent from the list of
// authorized reporters.
type MsgRemoveOracleAddress struct {
	Validator github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,1,opt,name=validator,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"validator,omitempty"`
	Reporter  github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=reporter,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"reporter,omitempty"`
}

func (m *MsgRemoveOracleAddress) Reset()         { *m = MsgRemoveOracleAddress{} }
func (m *MsgRemoveOracleAddress) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveOracleAddress) ProtoMessage()    {}
func (*MsgRemoveOracleAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{7}
}
func (m *MsgRemoveOracleAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveOracleAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveOracleAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveOracleAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveOracleAddress.Merge(m, src)
}
func (m *MsgRemoveOracleAddress) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveOracleAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveOracleAddress.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveOracleAddress proto.InternalMessageInfo

func (m *MsgRemoveOracleAddress) GetValidator() github_com_cosmos_cosmos_sdk_types.ValAddress {
	if m != nil {
		return m.Validator
	}
	return nil
}

func (m *MsgRemoveOracleAddress) GetReporter() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Reporter
	}
	return nil
}

// DataSource is the data structure for storing data sources in the storage.
type DataSource struct {
	Owner       github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	Name        string                                        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description string                                        `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Fee         github_com_cosmos_cosmos_sdk_types.Coins      `protobuf:"bytes,4,rep,name=fee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee"`
	Executable  []byte                                        `protobuf:"bytes,5,opt,name=executable,proto3" json:"executable,omitempty"`
}

func (m *DataSource) Reset()         { *m = DataSource{} }
func (m *DataSource) String() string { return proto.CompactTextString(m) }
func (*DataSource) ProtoMessage()    {}
func (*DataSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{8}
}
func (m *DataSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSource.Merge(m, src)
}
func (m *DataSource) XXX_Size() int {
	return m.Size()
}
func (m *DataSource) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSource.DiscardUnknown(m)
}

var xxx_messageInfo_DataSource proto.InternalMessageInfo

func (m *DataSource) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *DataSource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DataSource) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DataSource) GetFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *DataSource) GetExecutable() []byte {
	if m != nil {
		return m.Executable
	}
	return nil
}

// OracleScript is a type to store detail of oracle script.
type OracleScript struct {
	Owner         github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	Name          string                                        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description   string                                        `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Code          []byte                                        `protobuf:"bytes,4,opt,name=code,proto3" json:"code,omitempty"`
	Schema        string                                        `protobuf:"bytes,5,opt,name=schema,proto3" json:"schema,omitempty"`
	SourceCodeURL string                                        `protobuf:"bytes,6,opt,name=source_code_url,json=sourceCodeUrl,proto3" json:"source_code_url,omitempty"`
}

func (m *OracleScript) Reset()         { *m = OracleScript{} }
func (m *OracleScript) String() string { return proto.CompactTextString(m) }
func (*OracleScript) ProtoMessage()    {}
func (*OracleScript) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{9}
}
func (m *OracleScript) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleScript) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleScript.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleScript) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleScript.Merge(m, src)
}
func (m *OracleScript) XXX_Size() int {
	return m.Size()
}
func (m *OracleScript) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleScript.DiscardUnknown(m)
}

var xxx_messageInfo_OracleScript proto.InternalMessageInfo

func (m *OracleScript) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *OracleScript) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OracleScript) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *OracleScript) GetCode() []byte {
	if m != nil {
		return m.Code
	}
	return nil
}

func (m *OracleScript) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *OracleScript) GetSourceCodeURL() string {
	if m != nil {
		return m.SourceCodeURL
	}
	return ""
}

// RawRequest is a raw data request that contain external id.
type RawRequest struct {
	ExternalID   ExternalID   `protobuf:"varint,1,opt,name=external_id,json=externalId,proto3,casttype=ExternalID" json:"external_id,omitempty"`
	DataSourceID DataSourceID `protobuf:"varint,2,opt,name=data_source_id,json=dataSourceId,proto3,casttype=DataSourceID" json:"data_source_id,omitempty"`
	Calldata     []byte       `protobuf:"bytes,3,opt,name=calldata,proto3" json:"calldata,omitempty"`
}

func (m *RawRequest) Reset()         { *m = RawRequest{} }
func (m *RawRequest) String() string { return proto.CompactTextString(m) }
func (*RawRequest) ProtoMessage()    {}
func (*RawRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{10}
}
func (m *RawRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawRequest.Merge(m, src)
}
func (m *RawRequest) XXX_Size() int {
	return m.Size()
}
func (m *RawRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RawRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RawRequest proto.InternalMessageInfo

func (m *RawRequest) GetExternalID() ExternalID {
	if m != nil {
		return m.ExternalID
	}
	return 0
}

func (m *RawRequest) GetDataSourceID() DataSourceID {
	if m != nil {
		return m.DataSourceID
	}
	return 0
}

func (m *RawRequest) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

// RawReport encapsulates a raw data report for an external data source from a
// block validator.
type RawReport struct {
	ExternalID ExternalID `protobuf:"varint,1,opt,name=external_id,json=externalId,proto3,casttype=ExternalID" json:"external_id,omitempty"`
	ExitCode   uint32     `protobuf:"varint,2,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	Data       []byte     `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *RawReport) Reset()         { *m = RawReport{} }
func (m *RawReport) String() string { return proto.CompactTextString(m) }
func (*RawReport) ProtoMessage()    {}
func (*RawReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{11}
}
func (m *RawReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawReport.Merge(m, src)
}
func (m *RawReport) XXX_Size() int {
	return m.Size()
}
func (m *RawReport) XXX_DiscardUnknown() {
	xxx_messageInfo_RawReport.DiscardUnknown(m)
}

var xxx_messageInfo_RawReport proto.InternalMessageInfo

func (m *RawReport) GetExternalID() ExternalID {
	if m != nil {
		return m.ExternalID
	}
	return 0
}

func (m *RawReport) GetExitCode() uint32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *RawReport) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// OracleRequestPacketData encodes an oracle request sent from other blockchains
// to BandChain.
type OracleRequestPacketData struct {
	// ClientID is the unique identifier of this oracle request, as specified by
	// the client. This same unique ID will be sent back to the requester with the
	// oracle response.
	ClientID string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// OracleScriptID is the unique identifier of the oracle script to be
	// executed.
	OracleScriptID OracleScriptID `protobuf:"varint,2,opt,name=oracle_script_id,json=oracleScriptId,proto3,casttype=OracleScriptID" json:"oracle_script_id,omitempty"`
	// Calldata is the hex-encoded of the calldata bytes available for oracle
	// execution during both preparation and execution phases.
	Calldata string `protobuf:"bytes,3,opt,name=calldata,proto3" json:"calldata,omitempty"`
	// AskCount is the number of validators that are requested to respond to this
	// oracle request. Higher value means more security, at a higher gas cost.
	AskCount int64 `protobuf:"varint,4,opt,name=ask_count,json=askCount,proto3" json:"ask_count,omitempty"`
	// MinCount is the minimum number of validators necessary for the request to
	// proceed to the execution phase. Higher value means more security, at the
	// cost of liveness.
	MinCount int64 `protobuf:"varint,5,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty"`
}

func (m *OracleRequestPacketData) Reset()         { *m = OracleRequestPacketData{} }
func (m *OracleRequestPacketData) String() string { return proto.CompactTextString(m) }
func (*OracleRequestPacketData) ProtoMessage()    {}
func (*OracleRequestPacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{12}
}
func (m *OracleRequestPacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleRequestPacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleRequestPacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleRequestPacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleRequestPacketData.Merge(m, src)
}
func (m *OracleRequestPacketData) XXX_Size() int {
	return m.Size()
}
func (m *OracleRequestPacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleRequestPacketData.DiscardUnknown(m)
}

var xxx_messageInfo_OracleRequestPacketData proto.InternalMessageInfo

func (m *OracleRequestPacketData) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OracleRequestPacketData) GetOracleScriptID() OracleScriptID {
	if m != nil {
		return m.OracleScriptID
	}
	return 0
}

func (m *OracleRequestPacketData) GetCalldata() string {
	if m != nil {
		return m.Calldata
	}
	return ""
}

func (m *OracleRequestPacketData) GetAskCount() int64 {
	if m != nil {
		return m.AskCount
	}
	return 0
}

func (m *OracleRequestPacketData) GetMinCount() int64 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

// OracleResponsePacketData encodes an oracle response from BandChain to the
// requester.
type OracleResponsePacketData struct {
	// ClientID is the unique identifier matched with that of the oracle request
	// packet.
	ClientID string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// RequestID is BandChain's unique identifier for this oracle request.
	// TODO: This is not actually needed, but is here to simplify DB. Should
	// remove.
	RequestID RequestID `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	// AnsCount is the number of validators among to the asked validators that
	// actually responded to this oracle request prior to this oracle request
	// being resolved.
	AnsCount int64 `protobuf:"varint,3,opt,name=ans_count,json=ansCount,proto3" json:"ans_count,omitempty"`
	// RequestTime is the UNIX epoch time at which the request was sent to
	// BandChain.
	RequestTime int64 `protobuf:"varint,4,opt,name=request_time,json=requestTime,proto3" json:"request_time,omitempty"`
	// ResolveTime is the UNIX epoch time at which the request was resolved to the
	// final result.
	ResolveTime int64 `protobuf:"varint,5,opt,name=resolve_time,json=resolveTime,proto3" json:"resolve_time,omitempty"`
	// ResolveStatus is the status of this oracle request, which can be OK, ERROR,
	// or EXPIRED.
	ResolveStatus ResolveStatus `protobuf:"varint,6,opt,name=resolve_status,json=resolveStatus,proto3,enum=bandchain.chain.x.oracle.v1.ResolveStatus" json:"resolve_status,omitempty"`
	// Result is the hex-encoded of the final aggregated value only available if
	// status if OK.
	Result string `protobuf:"bytes,7,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *OracleResponsePacketData) Reset()         { *m = OracleResponsePacketData{} }
func (m *OracleResponsePacketData) String() string { return proto.CompactTextString(m) }
func (*OracleResponsePacketData) ProtoMessage()    {}
func (*OracleResponsePacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{13}
}
func (m *OracleResponsePacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleResponsePacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleResponsePacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleResponsePacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleResponsePacketData.Merge(m, src)
}
func (m *OracleResponsePacketData) XXX_Size() int {
	return m.Size()
}
func (m *OracleResponsePacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleResponsePacketData.DiscardUnknown(m)
}

var xxx_messageInfo_OracleResponsePacketData proto.InternalMessageInfo

func (m *OracleResponsePacketData) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OracleResponsePacketData) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *OracleResponsePacketData) GetAnsCount() int64 {
	if m != nil {
		return m.AnsCount
	}
	return 0
}

func (m *OracleResponsePacketData) GetRequestTime() int64 {
	if m != nil {
		return m.RequestTime
	}
	return 0
}

func (m *OracleResponsePacketData) GetResolveTime() int64 {
	if m != nil {
		return m.ResolveTime
	}
	return 0
}

func (m *OracleResponsePacketData) GetResolveStatus() ResolveStatus {
	if m != nil {
		return m.ResolveStatus
	}
	return ResolveStatus_Open
}

func (m *OracleResponsePacketData) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

// Request is a data structure that stores the detail of a request to an oracle
// script.
type Request struct {
	OracleScriptID           OracleScriptID                                  `protobuf:"varint,1,opt,name=oracle_script_id,json=oracleScriptId,proto3,casttype=OracleScriptID" json:"oracle_script_id,omitempty"`
	Calldata                 []byte                                          `protobuf:"bytes,2,opt,name=calldata,proto3" json:"calldata,omitempty"`
	RequestedValidators      []github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,3,rep,name=requested_validators,json=requestedValidators,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"requested_validators,omitempty"`
	SufficientValidatorCount int64                                           `protobuf:"varint,4,opt,name=sufficient_validator_count,json=sufficientValidatorCount,proto3" json:"sufficient_validator_count,omitempty"`
	RequestHeight            int64                                           `protobuf:"varint,5,opt,name=request_height,json=requestHeight,proto3" json:"request_height,omitempty"`
	RequestTime              int64                                           `protobuf:"varint,6,opt,name=request_time,json=requestTime,proto3" json:"request_time,omitempty"`
	ClientID                 string                                          `protobuf:"bytes,7,opt,name=Client_id,json=ClientId,proto3" json:"Client_id,omitempty"`
	IBC                      *RequestIBC                                     `protobuf:"bytes,8,opt,name=ibc,proto3" json:"ibc,omitempty"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{14}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetOracleScriptID() OracleScriptID {
	if m != nil {
		return m.OracleScriptID
	}
	return 0
}

func (m *Request) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

func (m *Request) GetRequestedValidators() []github_com_cosmos_cosmos_sdk_types.ValAddress {
	if m != nil {
		return m.RequestedValidators
	}
	return nil
}

func (m *Request) GetSufficientValidatorCount() int64 {
	if m != nil {
		return m.SufficientValidatorCount
	}
	return 0
}

func (m *Request) GetRequestHeight() int64 {
	if m != nil {
		return m.RequestHeight
	}
	return 0
}

func (m *Request) GetRequestTime() int64 {
	if m != nil {
		return m.RequestTime
	}
	return 0
}

func (m *Request) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Request) GetIBC() *RequestIBC {
	if m != nil {
		return m.IBC
	}
	return nil
}

type RequestIBC struct {
	SourcePort    string `protobuf:"bytes,1,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
	SourceChannel string `protobuf:"bytes,2,opt,name=source_channel,json=sourceChannel,proto3" json:"source_channel,omitempty"`
}

func (m *RequestIBC) Reset()         { *m = RequestIBC{} }
func (m *RequestIBC) String() string { return proto.CompactTextString(m) }
func (*RequestIBC) ProtoMessage()    {}
func (*RequestIBC) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{15}
}
func (m *RequestIBC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestIBC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestIBC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestIBC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestIBC.Merge(m, src)
}
func (m *RequestIBC) XXX_Size() int {
	return m.Size()
}
func (m *RequestIBC) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestIBC.DiscardUnknown(m)
}

var xxx_messageInfo_RequestIBC proto.InternalMessageInfo

func (m *RequestIBC) GetSourcePort() string {
	if m != nil {
		return m.SourcePort
	}
	return ""
}

func (m *RequestIBC) GetSourceChannel() string {
	if m != nil {
		return m.SourceChannel
	}
	return ""
}

func init() {
	proto.RegisterEnum("bandchain.chain.x.oracle.v1.ResolveStatus", ResolveStatus_name, ResolveStatus_value)
	proto.RegisterType((*MsgRequestData)(nil), "bandchain.chain.x.oracle.v1.MsgRequestData")
	proto.RegisterType((*MsgReportData)(nil), "bandchain.chain.x.oracle.v1.MsgReportData")
	proto.RegisterType((*MsgCreateDataSource)(nil), "bandchain.chain.x.oracle.v1.MsgCreateDataSource")
	proto.RegisterType((*MsgEditDataSource)(nil), "bandchain.chain.x.oracle.v1.MsgEditDataSource")
	proto.RegisterType((*MsgCreateOracleScript)(nil), "bandchain.chain.x.oracle.v1.MsgCreateOracleScript")
	proto.RegisterType((*MsgEditOracleScript)(nil), "bandchain.chain.x.oracle.v1.MsgEditOracleScript")
	proto.RegisterType((*MsgAddOracleAddress)(nil), "bandchain.chain.x.oracle.v1.MsgAddOracleAddress")
	proto.RegisterType((*MsgRemoveOracleAddress)(nil), "bandchain.chain.x.oracle.v1.MsgRemoveOracleAddress")
	proto.RegisterType((*DataSource)(nil), "bandchain.chain.x.oracle.v1.DataSource")
	proto.RegisterType((*OracleScript)(nil), "bandchain.chain.x.oracle.v1.OracleScript")
	proto.RegisterType((*RawRequest)(nil), "bandchain.chain.x.oracle.v1.RawRequest")
	proto.RegisterType((*RawReport)(nil), "bandchain.chain.x.oracle.v1.RawReport")
	proto.RegisterType((*OracleRequestPacketData)(nil), "bandchain.chain.x.oracle.v1.OracleRequestPacketData")
	proto.RegisterType((*OracleResponsePacketData)(nil), "bandchain.chain.x.oracle.v1.OracleResponsePacketData")
	proto.RegisterType((*Request)(nil), "bandchain.chain.x.oracle.v1.Request")
	proto.RegisterType((*RequestIBC)(nil), "bandchain.chain.x.oracle.v1.RequestIBC")
}

func init() { proto.RegisterFile("x/oracle/types/types.proto", fileDescriptor_53e65fd95a58412c) }

var fileDescriptor_53e65fd95a58412c = []byte{
	// 1260 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xcd, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0xee, 0xfa, 0x6b, 0x9f, 0x3f, 0x48, 0xb7, 0xd0, 0x1a, 0x07, 0x79, 0x4d, 0x44, 0x8b,
	0x5b, 0xa9, 0x36, 0x0d, 0x12, 0x52, 0x2b, 0x90, 0x88, 0x9d, 0x14, 0x2c, 0x11, 0x12, 0x36, 0x6d,
	0x91, 0xb8, 0x58, 0x93, 0x9d, 0x89, 0xbd, 0xca, 0x7a, 0xd7, 0xec, 0xac, 0x53, 0xf7, 0xc8, 0x95,
	0x13, 0x7f, 0x00, 0x07, 0x0e, 0x9c, 0xb8, 0x73, 0x42, 0xe2, 0x4a, 0x4f, 0xa8, 0xe2, 0xc4, 0xc9,
	0x20, 0xe7, 0x82, 0x38, 0x72, 0xcc, 0x09, 0xcd, 0xc7, 0x7a, 0x6d, 0x9c, 0xa6, 0x6d, 0x6a, 0xa8,
	0x10, 0x5c, 0xac, 0x7d, 0x6f, 0xde, 0x7c, 0xfd, 0x7e, 0xef, 0x63, 0x9e, 0xa1, 0x34, 0xac, 0xfb,
	0x01, 0xb2, 0x5d, 0x52, 0x0f, 0xef, 0xf7, 0x09, 0x15, 0xbf, 0xb5, 0x7e, 0xe0, 0x87, 0xbe, 0xb1,
	0xb2, 0x87, 0x3c, 0x6c, 0x77, 0x91, 0xe3, 0xd5, 0xc4, 0xef, 0xb0, 0x26, 0x6c, 0x6b, 0x87, 0xd7,
	0x4b, 0x97, 0xc3, 0xae, 0x13, 0xe0, 0x76, 0x1f, 0x05, 0xe1, 0xfd, 0x3a, 0xb7, 0xaf, 0x77, 0xfc,
	0x8e, 0x1f, 0x7f, 0x89, 0x45, 0x4a, 0xd5, 0x79, 0x3b, 0xdb, 0xa7, 0x3d, 0x9f, 0x5e, 0x13, 0x02,
	0xc5, 0x07, 0xc2, 0x72, 0xf5, 0x0f, 0x15, 0x0a, 0x5b, 0xb4, 0x63, 0x91, 0x4f, 0x07, 0x84, 0x86,
	0x1b, 0x28, 0x44, 0xc6, 0x87, 0xb0, 0x2c, 0x76, 0x6c, 0x53, 0x3b, 0x70, 0xfa, 0x61, 0xdb, 0xc1,
	0x45, 0xa5, 0xa2, 0x54, 0xb5, 0xc6, 0x6b, 0xe3, 0x91, 0x59, 0xd8, 0xe6, 0x63, 0xbb, 0x7c, 0xa8,
	0xb5, 0x71, 0x3c, 0xa7, 0xb1, 0x0a, 0xfe, 0xb4, 0x8c, 0x8d, 0x12, 0x64, 0x6c, 0xe4, 0xba, 0x18,
	0x85, 0xa8, 0xa8, 0x56, 0x94, 0x6a, 0xce, 0x9a, 0xc8, 0xc6, 0x4d, 0x78, 0x39, 0x10, 0x5b, 0x13,
	0xdc, 0x3e, 0x44, 0xae, 0x83, 0x51, 0xe8, 0x07, 0x6d, 0xdb, 0x1f, 0x78, 0x61, 0x51, 0x63, 0x9b,
	0x5a, 0x17, 0x27, 0x06, 0x77, 0xa3, 0xf1, 0x26, 0x1b, 0x36, 0xde, 0x86, 0x12, 0x1d, 0xec, 0xef,
	0x3b, 0xb6, 0x43, 0xbc, 0x70, 0x6e, 0x72, 0x82, 0x4f, 0x2e, 0xc6, 0x16, 0x7f, 0x99, 0x7d, 0x05,
	0x74, 0xdb, 0xe5, 0x33, 0x1d, 0x5c, 0x4c, 0x56, 0x94, 0xaa, 0xde, 0xc8, 0x8d, 0x47, 0x66, 0xa6,
	0xc9, 0x95, 0xad, 0x0d, 0x2b, 0x23, 0x86, 0x5b, 0xd8, 0x68, 0x41, 0x8a, 0x12, 0x0f, 0x93, 0xa0,
	0x98, 0x62, 0xc7, 0x6f, 0x5c, 0x3f, 0x1e, 0x99, 0xd7, 0x3a, 0x4e, 0xd8, 0x1d, 0xec, 0xd5, 0x6c,
	0xbf, 0x27, 0xa1, 0x8d, 0x10, 0xa6, 0xf8, 0x40, 0x12, 0xba, 0x6e, 0xdb, 0xeb, 0x18, 0x07, 0x84,
	0x52, 0x4b, 0x2e, 0x70, 0x33, 0xf1, 0xdb, 0x57, 0xa6, 0xb2, 0xfa, 0x83, 0x0a, 0x79, 0x0e, 0x7a,
	0xdf, 0x0f, 0x04, 0xe6, 0x37, 0x00, 0xe4, 0x35, 0x63, 0xb4, 0x4b, 0xe3, 0x91, 0xa9, 0x4b, 0x62,
	0x38, 0xd0, 0xb1, 0x60, 0xe9, 0xd2, 0xba, 0x85, 0x8d, 0x3b, 0x90, 0x61, 0x50, 0xb6, 0x29, 0x09,
	0x8b, 0x6a, 0x45, 0xab, 0x66, 0xd7, 0x2e, 0xd7, 0x4e, 0xf1, 0xa1, 0x9a, 0x85, 0xee, 0x89, 0x8d,
	0x1b, 0xc6, 0x83, 0x91, 0xb9, 0xf4, 0xcd, 0x2f, 0x26, 0x4c, 0x54, 0xd4, 0x4a, 0xb3, 0xb5, 0x76,
	0x49, 0x68, 0x6c, 0x83, 0x3e, 0x81, 0x94, 0x33, 0xf1, 0xe4, 0xf7, 0xbe, 0x8b, 0xdc, 0xe8, 0xde,
	0xf1, 0x1a, 0xc6, 0x16, 0x64, 0x02, 0xbe, 0x09, 0x09, 0x38, 0x39, 0x67, 0xc2, 0x71, 0xb2, 0x84,
	0x44, 0x72, 0xa4, 0xc2, 0xf9, 0x2d, 0xda, 0x69, 0x06, 0x04, 0x85, 0x84, 0x21, 0xb9, 0xeb, 0x0f,
	0x02, 0x9b, 0x18, 0xef, 0x41, 0xd2, 0xbf, 0xe7, 0x91, 0x80, 0x43, 0x79, 0xa6, 0x9d, 0xc4, 0x7c,
	0xc3, 0x80, 0x84, 0x87, 0x7a, 0x84, 0x3b, 0xae, 0x6e, 0xf1, 0x6f, 0xa3, 0x02, 0x59, 0x4c, 0x44,
	0x6c, 0x38, 0xbe, 0xc7, 0xc1, 0xd1, 0xad, 0x69, 0x95, 0xf1, 0x31, 0x68, 0xfb, 0x84, 0x14, 0x13,
	0x9c, 0x8e, 0xf3, 0x35, 0xb1, 0x4f, 0x9b, 0x45, 0xdd, 0xe1, 0xf5, 0x5a, 0xd3, 0x77, 0xbc, 0xc6,
	0x1b, 0x12, 0xfb, 0xea, 0x13, 0x9c, 0x8a, 0x4d, 0xa0, 0x16, 0x5b, 0xd1, 0x28, 0x03, 0x90, 0x21,
	0xb1, 0x07, 0x21, 0xda, 0x73, 0x09, 0x77, 0xdb, 0x9c, 0x35, 0xa5, 0x59, 0xbc, 0xab, 0x7e, 0xad,
	0xc1, 0xb9, 0x2d, 0xda, 0xd9, 0xc4, 0x4e, 0x38, 0x05, 0xef, 0x2d, 0x28, 0x08, 0x9f, 0xe3, 0x62,
	0xec, 0xb2, 0x95, 0xf1, 0xc8, 0xcc, 0xc5, 0x76, 0xdc, 0x6b, 0x67, 0x64, 0x2b, 0x87, 0x63, 0x09,
	0xc7, 0x34, 0xa9, 0x0b, 0xa2, 0x49, 0x7b, 0x34, 0x4d, 0x89, 0x47, 0xd2, 0x94, 0xfc, 0x9b, 0x69,
	0x4a, 0x9d, 0x42, 0x53, 0x7a, 0x31, 0x34, 0xfd, 0xa8, 0xc2, 0x4b, 0x93, 0x38, 0x98, 0xce, 0xc7,
	0xcf, 0x3b, 0x12, 0x0c, 0x48, 0xd8, 0x3e, 0x26, 0x22, 0xe2, 0x2d, 0xfe, 0x6d, 0x5c, 0x80, 0x14,
	0xb5, 0xbb, 0xa4, 0x87, 0x44, 0xde, 0xb5, 0xa4, 0x64, 0xdc, 0x80, 0x17, 0xa4, 0x43, 0x31, 0xb3,
	0xf6, 0x20, 0x70, 0x39, 0x74, 0x7a, 0xe3, 0xdc, 0x78, 0x64, 0xe6, 0x85, 0xd3, 0x34, 0x7d, 0x4c,
	0xee, 0x58, 0x1f, 0x58, 0x79, 0x1a, 0x8b, 0x81, 0xbb, 0x78, 0x40, 0xbf, 0xd4, 0x78, 0x62, 0x61,
	0x7e, 0x3f, 0x03, 0xe7, 0xa2, 0x8b, 0xe3, 0x73, 0x8e, 0x80, 0x88, 0x9e, 0xe4, 0x89, 0xf4, 0xa4,
	0x1e, 0x47, 0x4f, 0xfa, 0xa9, 0xe9, 0xc9, 0x2c, 0x86, 0x9e, 0xef, 0x14, 0x4e, 0xcf, 0x3a, 0xc6,
	0x02, 0x5f, 0x69, 0x35, 0x5b, 0xb5, 0x94, 0x05, 0x57, 0x2d, 0x75, 0x51, 0x55, 0xeb, 0x7b, 0x05,
	0x2e, 0xf0, 0xfa, 0xdf, 0xf3, 0x0f, 0xc9, 0xbf, 0xf1, 0x02, 0x9f, 0xab, 0x00, 0xff, 0x57, 0x5b,
	0x09, 0xc6, 0xb1, 0x02, 0xb9, 0xff, 0x5e, 0xca, 0x95, 0x97, 0xff, 0x56, 0x01, 0xf1, 0x7c, 0xe4,
	0xcf, 0x51, 0xe3, 0x1d, 0xc8, 0x92, 0x61, 0x48, 0x02, 0x0f, 0xb9, 0x71, 0x66, 0x7c, 0x65, 0x3c,
	0x32, 0x61, 0x53, 0xaa, 0x79, 0x56, 0x9c, 0x92, 0x18, 0xa0, 0xf2, 0x1b, 0x9f, 0xf0, 0xae, 0x50,
	0xcf, 0xf4, 0xae, 0x98, 0x6e, 0x39, 0xb4, 0xd9, 0x96, 0x43, 0x9e, 0xfb, 0x33, 0x05, 0xf4, 0xc9,
	0xb3, 0xf7, 0x59, 0x8f, 0xbd, 0x02, 0x3a, 0x19, 0x3a, 0x21, 0xc7, 0x90, 0x9f, 0x38, 0x6f, 0x65,
	0x98, 0x82, 0x41, 0xc5, 0xe8, 0x98, 0x3a, 0x47, 0x62, 0xea, 0x0c, 0xbf, 0x2b, 0x70, 0x51, 0x38,
	0x8e, 0x84, 0x6f, 0x07, 0xd9, 0x07, 0x44, 0x34, 0x04, 0x33, 0xed, 0x89, 0x72, 0x6a, 0x7b, 0x72,
	0x52, 0x49, 0x52, 0x17, 0xd4, 0xaf, 0x09, 0xf7, 0x8a, 0xfb, 0xb5, 0x15, 0xd0, 0x11, 0x3d, 0x98,
	0x69, 0xb1, 0x32, 0x88, 0x1e, 0x88, 0x96, 0x6a, 0x05, 0xf4, 0x9e, 0xe3, 0xc9, 0xc1, 0xa4, 0x18,
	0xec, 0x39, 0x1e, 0x1f, 0x64, 0x2f, 0x94, 0x62, 0x74, 0x59, 0xda, 0xf7, 0x3d, 0x4a, 0xce, 0x76,
	0xdb, 0xd9, 0x4e, 0x49, 0x7d, 0x9a, 0x4e, 0x89, 0x1d, 0xde, 0xa3, 0x33, 0xcd, 0x65, 0x06, 0x79,
	0x54, 0x1c, 0xfe, 0x55, 0xc8, 0x45, 0xeb, 0x86, 0x4e, 0x8f, 0xc8, 0xcb, 0x65, 0xa5, 0xee, 0xb6,
	0xd3, 0x23, 0xc2, 0x84, 0xfa, 0xee, 0x21, 0x11, 0x26, 0xc9, 0xc8, 0x84, 0xeb, 0xb8, 0xc9, 0x47,
	0x50, 0x88, 0x4c, 0x68, 0x88, 0xc2, 0x01, 0xe5, 0xe1, 0x54, 0x58, 0xbb, 0x7a, 0x7a, 0x4b, 0x26,
	0xa6, 0xec, 0xf2, 0x19, 0x56, 0x3e, 0x98, 0x16, 0x59, 0xe8, 0x06, 0x84, 0x0e, 0xdc, 0x50, 0x54,
	0x5b, 0x4b, 0x4a, 0xab, 0x3f, 0x69, 0x90, 0x8e, 0xc2, 0xee, 0x9f, 0x6c, 0xd9, 0x31, 0xbc, 0x78,
	0x42, 0xcb, 0x4e, 0x8b, 0x5a, 0x45, 0x3b, 0x5b, 0xb1, 0x3a, 0x3f, 0xdf, 0xe0, 0xd3, 0x67, 0x6c,
	0xee, 0x2f, 0x31, 0x1a, 0x04, 0x99, 0x5d, 0xe2, 0x74, 0xba, 0x91, 0x3b, 0xe6, 0xa5, 0xf6, 0x7d,
	0xae, 0x9c, 0xe3, 0x3c, 0x35, 0xcf, 0xf9, 0x15, 0xd0, 0x9b, 0x13, 0xcf, 0x4c, 0x9f, 0xe4, 0x99,
	0xcd, 0xc8, 0x33, 0x1b, 0xa0, 0x39, 0x7b, 0x36, 0x7f, 0xe1, 0x64, 0xd7, 0x5e, 0x7f, 0x0c, 0xe1,
	0xc2, 0x27, 0x1b, 0xcd, 0x46, 0x7a, 0x3c, 0x32, 0xb5, 0x56, 0xa3, 0x69, 0xb1, 0xc9, 0xab, 0xb7,
	0x01, 0xe2, 0x31, 0xc3, 0x84, 0xac, 0xcc, 0x84, 0x2c, 0x4b, 0x89, 0xc0, 0xb0, 0x40, 0xa8, 0x76,
	0x58, 0xde, 0xba, 0x04, 0x85, 0x28, 0x7d, 0x77, 0x91, 0xe7, 0x11, 0x57, 0x96, 0x8a, 0x28, 0x55,
	0x0b, 0xe5, 0xd5, 0x77, 0x21, 0x3f, 0xe3, 0x62, 0x46, 0x06, 0x12, 0xdb, 0x7d, 0xe2, 0x2d, 0x2f,
	0x19, 0x59, 0x48, 0xef, 0x0e, 0x6c, 0x9b, 0x50, 0xba, 0xac, 0x30, 0xe1, 0x16, 0x72, 0xdc, 0x41,
	0x40, 0x96, 0x55, 0x26, 0x6c, 0x0e, 0xfb, 0x4e, 0x40, 0xf0, 0xb2, 0xd6, 0xd8, 0x79, 0x30, 0x2e,
	0x2b, 0x0f, 0xc7, 0x65, 0xe5, 0xd7, 0x71, 0x59, 0xf9, 0xe2, 0xa8, 0xbc, 0xf4, 0xf0, 0xa8, 0xbc,
	0xf4, 0xf3, 0x51, 0x79, 0xe9, 0x93, 0xb7, 0xa6, 0xc8, 0x66, 0x57, 0xe6, 0x7f, 0x2b, 0xd9, 0xbe,
	0x5b, 0x9f, 0xdc, 0xbf, 0x2e, 0x7e, 0x67, 0xff, 0xf3, 0xda, 0x4b, 0x71, 0xc3, 0x37, 0xff, 0x0c,
	0x00, 0x00, 0xff, 0xff, 0xe8, 0x1e, 0x3c, 0xea, 0x0c, 0x13, 0x00, 0x00,
}

func (this *MsgRequestData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgRequestData)
	if !ok {
		that2, ok := that.(MsgRequestData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OracleScriptID != that1.OracleScriptID {
		return false
	}
	if !bytes.Equal(this.Calldata, that1.Calldata) {
		return false
	}
	if this.RequestedValidatorCount != that1.RequestedValidatorCount {
		return false
	}
	if this.SufficientValidatorCount != that1.SufficientValidatorCount {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if !bytes.Equal(this.Sender, that1.Sender) {
		return false
	}
	return true
}
func (this *MsgReportData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgReportData)
	if !ok {
		that2, ok := that.(MsgReportData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if len(this.DataSet) != len(that1.DataSet) {
		return false
	}
	for i := range this.DataSet {
		if !this.DataSet[i].Equal(&that1.DataSet[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Validator, that1.Validator) {
		return false
	}
	if !bytes.Equal(this.Reporter, that1.Reporter) {
		return false
	}
	return true
}
func (this *MsgCreateDataSource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgCreateDataSource)
	if !ok {
		that2, ok := that.(MsgCreateDataSource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Owner, that1.Owner) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Fee) != len(that1.Fee) {
		return false
	}
	for i := range this.Fee {
		if !this.Fee[i].Equal(&that1.Fee[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Executable, that1.Executable) {
		return false
	}
	if !bytes.Equal(this.Sender, that1.Sender) {
		return false
	}
	return true
}
func (this *MsgEditDataSource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgEditDataSource)
	if !ok {
		that2, ok := that.(MsgEditDataSource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataSourceID != that1.DataSourceID {
		return false
	}
	if !bytes.Equal(this.Owner, that1.Owner) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Fee) != len(that1.Fee) {
		return false
	}
	for i := range this.Fee {
		if !this.Fee[i].Equal(&that1.Fee[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Executable, that1.Executable) {
		return false
	}
	if !bytes.Equal(this.Sender, that1.Sender) {
		return false
	}
	return true
}
func (this *MsgCreateOracleScript) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgCreateOracleScript)
	if !ok {
		that2, ok := that.(MsgCreateOracleScript)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Owner, that1.Owner) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !bytes.Equal(this.Code, that1.Code) {
		return false
	}
	if this.Schema != that1.Schema {
		return false
	}
	if this.SourceCodeURL != that1.SourceCodeURL {
		return false
	}
	if !bytes.Equal(this.Sender, that1.Sender) {
		return false
	}
	return true
}
func (this *MsgEditOracleScript) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgEditOracleScript)
	if !ok {
		that2, ok := that.(MsgEditOracleScript)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OracleScriptID != that1.OracleScriptID {
		return false
	}
	if !bytes.Equal(this.Owner, that1.Owner) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !bytes.Equal(this.Code, that1.Code) {
		return false
	}
	if this.Schema != that1.Schema {
		return false
	}
	if this.SourceCodeURL != that1.SourceCodeURL {
		return false
	}
	if !bytes.Equal(this.Sender, that1.Sender) {
		return false
	}
	return true
}
func (this *MsgAddOracleAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgAddOracleAddress)
	if !ok {
		that2, ok := that.(MsgAddOracleAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Validator, that1.Validator) {
		return false
	}
	if !bytes.Equal(this.Reporter, that1.Reporter) {
		return false
	}
	return true
}
func (this *MsgRemoveOracleAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgRemoveOracleAddress)
	if !ok {
		that2, ok := that.(MsgRemoveOracleAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Validator, that1.Validator) {
		return false
	}
	if !bytes.Equal(this.Reporter, that1.Reporter) {
		return false
	}
	return true
}
func (this *DataSource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataSource)
	if !ok {
		that2, ok := that.(DataSource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Owner, that1.Owner) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Fee) != len(that1.Fee) {
		return false
	}
	for i := range this.Fee {
		if !this.Fee[i].Equal(&that1.Fee[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Executable, that1.Executable) {
		return false
	}
	return true
}
func (this *OracleScript) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OracleScript)
	if !ok {
		that2, ok := that.(OracleScript)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Owner, that1.Owner) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !bytes.Equal(this.Code, that1.Code) {
		return false
	}
	if this.Schema != that1.Schema {
		return false
	}
	if this.SourceCodeURL != that1.SourceCodeURL {
		return false
	}
	return true
}
func (this *RawRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RawRequest)
	if !ok {
		that2, ok := that.(RawRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExternalID != that1.ExternalID {
		return false
	}
	if this.DataSourceID != that1.DataSourceID {
		return false
	}
	if !bytes.Equal(this.Calldata, that1.Calldata) {
		return false
	}
	return true
}
func (this *RawReport) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RawReport)
	if !ok {
		that2, ok := that.(RawReport)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExternalID != that1.ExternalID {
		return false
	}
	if this.ExitCode != that1.ExitCode {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (m *MsgRequestData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SufficientValidatorCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SufficientValidatorCount))
		i--
		dAtA[i] = 0x20
	}
	if m.RequestedValidatorCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequestedValidatorCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x12
	}
	if m.OracleScriptID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OracleScriptID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgReportData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReportData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReportData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reporter) > 0 {
		i -= len(m.Reporter)
		copy(dAtA[i:], m.Reporter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reporter)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DataSet) > 0 {
		for iNdEx := len(m.DataSet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.RequestID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDataSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDataSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDataSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Executable) > 0 {
		i -= len(m.Executable)
		copy(dAtA[i:], m.Executable)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Executable)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Fee) > 0 {
		for iNdEx := len(m.Fee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEditDataSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEditDataSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEditDataSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Executable) > 0 {
		i -= len(m.Executable)
		copy(dAtA[i:], m.Executable)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Executable)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Fee) > 0 {
		for iNdEx := len(m.Fee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.DataSourceID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DataSourceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateOracleScript) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateOracleScript) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateOracleScript) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SourceCodeURL) > 0 {
		i -= len(m.SourceCodeURL)
		copy(dAtA[i:], m.SourceCodeURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SourceCodeURL)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Schema) > 0 {
		i -= len(m.Schema)
		copy(dAtA[i:], m.Schema)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Schema)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEditOracleScript) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEditOracleScript) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEditOracleScript) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SourceCodeURL) > 0 {
		i -= len(m.SourceCodeURL)
		copy(dAtA[i:], m.SourceCodeURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SourceCodeURL)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Schema) > 0 {
		i -= len(m.Schema)
		copy(dAtA[i:], m.Schema)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Schema)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.OracleScriptID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OracleScriptID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddOracleAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddOracleAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddOracleAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reporter) > 0 {
		i -= len(m.Reporter)
		copy(dAtA[i:], m.Reporter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reporter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoveOracleAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveOracleAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveOracleAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reporter) > 0 {
		i -= len(m.Reporter)
		copy(dAtA[i:], m.Reporter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reporter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Executable) > 0 {
		i -= len(m.Executable)
		copy(dAtA[i:], m.Executable)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Executable)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Fee) > 0 {
		for iNdEx := len(m.Fee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleScript) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleScript) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleScript) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SourceCodeURL) > 0 {
		i -= len(m.SourceCodeURL)
		copy(dAtA[i:], m.SourceCodeURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SourceCodeURL)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Schema) > 0 {
		i -= len(m.Schema)
		copy(dAtA[i:], m.Schema)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Schema)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RawRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DataSourceID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DataSourceID))
		i--
		dAtA[i] = 0x10
	}
	if m.ExternalID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExternalID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RawReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ExitCode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExitCode))
		i--
		dAtA[i] = 0x10
	}
	if m.ExternalID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExternalID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OracleRequestPacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleRequestPacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleRequestPacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinCount))
		i--
		dAtA[i] = 0x28
	}
	if m.AskCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AskCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OracleScriptID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OracleScriptID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleResponsePacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleResponsePacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleResponsePacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ResolveStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResolveStatus))
		i--
		dAtA[i] = 0x30
	}
	if m.ResolveTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResolveTime))
		i--
		dAtA[i] = 0x28
	}
	if m.RequestTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequestTime))
		i--
		dAtA[i] = 0x20
	}
	if m.AnsCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AnsCount))
		i--
		dAtA[i] = 0x18
	}
	if m.RequestID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IBC != nil {
		{
			size, err := m.IBC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0x3a
	}
	if m.RequestTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequestTime))
		i--
		dAtA[i] = 0x30
	}
	if m.RequestHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequestHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.SufficientValidatorCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SufficientValidatorCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RequestedValidators) > 0 {
		for iNdEx := len(m.RequestedValidators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestedValidators[iNdEx])
			copy(dAtA[i:], m.RequestedValidators[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestedValidators[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x12
	}
	if m.OracleScriptID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OracleScriptID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestIBC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestIBC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestIBC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SourceChannel) > 0 {
		i -= len(m.SourceChannel)
		copy(dAtA[i:], m.SourceChannel)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SourceChannel)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SourcePort) > 0 {
		i -= len(m.SourcePort)
		copy(dAtA[i:], m.SourcePort)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SourcePort)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgRequestData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OracleScriptID != 0 {
		n += 1 + sovTypes(uint64(m.OracleScriptID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RequestedValidatorCount != 0 {
		n += 1 + sovTypes(uint64(m.RequestedValidatorCount))
	}
	if m.SufficientValidatorCount != 0 {
		n += 1 + sovTypes(uint64(m.SufficientValidatorCount))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgReportData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestID != 0 {
		n += 1 + sovTypes(uint64(m.RequestID))
	}
	if len(m.DataSet) > 0 {
		for _, e := range m.DataSet {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reporter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgCreateDataSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Executable)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgEditDataSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataSourceID != 0 {
		n += 1 + sovTypes(uint64(m.DataSourceID))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Executable)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgCreateOracleScript) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SourceCodeURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgEditOracleScript) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OracleScriptID != 0 {
		n += 1 + sovTypes(uint64(m.OracleScriptID))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SourceCodeURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgAddOracleAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reporter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgRemoveOracleAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reporter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *DataSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Executable)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *OracleScript) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SourceCodeURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RawRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExternalID != 0 {
		n += 1 + sovTypes(uint64(m.ExternalID))
	}
	if m.DataSourceID != 0 {
		n += 1 + sovTypes(uint64(m.DataSourceID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RawReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExternalID != 0 {
		n += 1 + sovTypes(uint64(m.ExternalID))
	}
	if m.ExitCode != 0 {
		n += 1 + sovTypes(uint64(m.ExitCode))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *OracleRequestPacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OracleScriptID != 0 {
		n += 1 + sovTypes(uint64(m.OracleScriptID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AskCount != 0 {
		n += 1 + sovTypes(uint64(m.AskCount))
	}
	if m.MinCount != 0 {
		n += 1 + sovTypes(uint64(m.MinCount))
	}
	return n
}

func (m *OracleResponsePacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RequestID != 0 {
		n += 1 + sovTypes(uint64(m.RequestID))
	}
	if m.AnsCount != 0 {
		n += 1 + sovTypes(uint64(m.AnsCount))
	}
	if m.RequestTime != 0 {
		n += 1 + sovTypes(uint64(m.RequestTime))
	}
	if m.ResolveTime != 0 {
		n += 1 + sovTypes(uint64(m.ResolveTime))
	}
	if m.ResolveStatus != 0 {
		n += 1 + sovTypes(uint64(m.ResolveStatus))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OracleScriptID != 0 {
		n += 1 + sovTypes(uint64(m.OracleScriptID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RequestedValidators) > 0 {
		for _, b := range m.RequestedValidators {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SufficientValidatorCount != 0 {
		n += 1 + sovTypes(uint64(m.SufficientValidatorCount))
	}
	if m.RequestHeight != 0 {
		n += 1 + sovTypes(uint64(m.RequestHeight))
	}
	if m.RequestTime != 0 {
		n += 1 + sovTypes(uint64(m.RequestTime))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IBC != nil {
		l = m.IBC.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RequestIBC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SourcePort)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SourceChannel)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgRequestData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScriptID", wireType)
			}
			m.OracleScriptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScriptID |= OracleScriptID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedValidatorCount", wireType)
			}
			m.RequestedValidatorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestedValidatorCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SufficientValidatorCount", wireType)
			}
			m.SufficientValidatorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SufficientValidatorCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReportData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReportData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReportData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataSet = append(m.DataSet, RawReport{})
			if err := m.DataSet[len(m.DataSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = append(m.Validator[:0], dAtA[iNdEx:postIndex]...)
			if m.Validator == nil {
				m.Validator = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = append(m.Reporter[:0], dAtA[iNdEx:postIndex]...)
			if m.Reporter == nil {
				m.Reporter = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDataSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDataSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDataSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, types.Coin{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executable", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executable = append(m.Executable[:0], dAtA[iNdEx:postIndex]...)
			if m.Executable == nil {
				m.Executable = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEditDataSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEditDataSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEditDataSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceID", wireType)
			}
			m.DataSourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSourceID |= DataSourceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, types.Coin{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executable", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executable = append(m.Executable[:0], dAtA[iNdEx:postIndex]...)
			if m.Executable == nil {
				m.Executable = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateOracleScript) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateOracleScript: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateOracleScript: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = append(m.Code[:0], dAtA[iNdEx:postIndex]...)
			if m.Code == nil {
				m.Code = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCodeURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceCodeURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEditOracleScript) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEditOracleScript: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEditOracleScript: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScriptID", wireType)
			}
			m.OracleScriptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScriptID |= OracleScriptID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = append(m.Code[:0], dAtA[iNdEx:postIndex]...)
			if m.Code == nil {
				m.Code = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCodeURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceCodeURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddOracleAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddOracleAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddOracleAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = append(m.Validator[:0], dAtA[iNdEx:postIndex]...)
			if m.Validator == nil {
				m.Validator = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = append(m.Reporter[:0], dAtA[iNdEx:postIndex]...)
			if m.Reporter == nil {
				m.Reporter = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveOracleAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveOracleAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveOracleAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = append(m.Validator[:0], dAtA[iNdEx:postIndex]...)
			if m.Validator == nil {
				m.Validator = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = append(m.Reporter[:0], dAtA[iNdEx:postIndex]...)
			if m.Reporter == nil {
				m.Reporter = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, types.Coin{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executable", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executable = append(m.Executable[:0], dAtA[iNdEx:postIndex]...)
			if m.Executable == nil {
				m.Executable = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleScript) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleScript: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleScript: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = append(m.Code[:0], dAtA[iNdEx:postIndex]...)
			if m.Code == nil {
				m.Code = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCodeURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceCodeURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			m.ExternalID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalID |= ExternalID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceID", wireType)
			}
			m.DataSourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSourceID |= DataSourceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			m.ExternalID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalID |= ExternalID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleRequestPacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleRequestPacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleRequestPacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScriptID", wireType)
			}
			m.OracleScriptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScriptID |= OracleScriptID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskCount", wireType)
			}
			m.AskCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AskCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCount", wireType)
			}
			m.MinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleResponsePacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleResponsePacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleResponsePacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnsCount", wireType)
			}
			m.AnsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnsCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			m.RequestTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveTime", wireType)
			}
			m.ResolveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolveTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveStatus", wireType)
			}
			m.ResolveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolveStatus |= ResolveStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScriptID", wireType)
			}
			m.OracleScriptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScriptID |= OracleScriptID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedValidators", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestedValidators = append(m.RequestedValidators, make([]byte, postIndex-iNdEx))
			copy(m.RequestedValidators[len(m.RequestedValidators)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SufficientValidatorCount", wireType)
			}
			m.SufficientValidatorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SufficientValidatorCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeight", wireType)
			}
			m.RequestHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			m.RequestTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IBC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IBC == nil {
				m.IBC = &RequestIBC{}
			}
			if err := m.IBC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestIBC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestIBC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestIBC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourcePort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
